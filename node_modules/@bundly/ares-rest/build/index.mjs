// src/canister-client/api-rest.did.ts
var idlFactory = ({ IDL }) => {
  return IDL.Service({
    http_request: IDL.Func(
      [
        IDL.Record({
          url: IDL.Text,
          method: IDL.Text,
          body: IDL.Vec(IDL.Nat8),
          headers: IDL.Vec(IDL.Tuple(IDL.Text, IDL.Text)),
          certificate_version: IDL.Opt(IDL.Nat16)
        })
      ],
      [
        IDL.Record({
          body: IDL.Vec(IDL.Nat8),
          headers: IDL.Vec(IDL.Tuple(IDL.Text, IDL.Text)),
          upgrade: IDL.Opt(IDL.Bool),
          streaming_strategy: IDL.Opt(
            IDL.Variant({
              Callback: IDL.Record({
                token: IDL.Vec(IDL.Nat8),
                callback: IDL.Func(
                  [IDL.Vec(IDL.Nat8)],
                  [
                    IDL.Opt(
                      IDL.Record({
                        token: IDL.Opt(IDL.Vec(IDL.Nat8)),
                        body: IDL.Vec(IDL.Nat8)
                      })
                    )
                  ],
                  ["query"]
                )
              })
            })
          ),
          status_code: IDL.Nat16
        })
      ],
      ["query"]
    ),
    http_request_update: IDL.Func(
      [
        IDL.Record({
          url: IDL.Text,
          method: IDL.Text,
          body: IDL.Vec(IDL.Nat8),
          headers: IDL.Vec(IDL.Tuple(IDL.Text, IDL.Text))
        })
      ],
      [
        IDL.Record({
          body: IDL.Vec(IDL.Nat8),
          headers: IDL.Vec(IDL.Tuple(IDL.Text, IDL.Text)),
          upgrade: IDL.Opt(IDL.Bool),
          streaming_strategy: IDL.Opt(
            IDL.Variant({
              Callback: IDL.Record({
                token: IDL.Vec(IDL.Nat8),
                callback: IDL.Func(
                  [IDL.Vec(IDL.Nat8)],
                  [
                    IDL.Opt(
                      IDL.Record({
                        token: IDL.Opt(IDL.Vec(IDL.Nat8)),
                        body: IDL.Vec(IDL.Nat8)
                      })
                    )
                  ],
                  ["query"]
                )
              })
            })
          ),
          status_code: IDL.Nat16
        })
      ],
      []
    )
  });
};

// src/canister-client/canister-client.ts
import { Actor, HttpAgent } from "@dfinity/agent";
import HttpStatus from "http-status-codes";

// src/canister-client/request-parsers.ts
function parseHeadersRequest(headers) {
  return Object.entries(headers);
}
function parseBodyRequest(data) {
  const encoder = new TextEncoder();
  if (typeof data === "string") {
    try {
      return encoder.encode(data);
    } catch (error) {
      const encoder2 = new TextEncoder();
      return encoder2.encode(data);
    }
  }
  if (Array.isArray(data) || typeof data === "object" && data !== null) {
    try {
      const jsonData = JSON.stringify(data);
      return encoder.encode(jsonData);
    } catch (error) {
      throw error;
    }
  }
  throw new Error("Data type not supported");
}

// src/canister-client/response-parsers.ts
function parseHeadersResponse(headers) {
  return headers.reduce((obj, [key, value]) => ({ ...obj, [key]: value }), {});
}
function parseBodyResponse(data) {
  if (data instanceof Uint8Array) {
    const stringData = (() => {
      try {
        const decoder = new TextDecoder("utf-8");
        return decoder.decode(data);
      } catch (error) {
        return null;
      }
    })();
    if (stringData !== null) {
      try {
        return JSON.parse(stringData);
      } catch (error) {
        return stringData;
      }
    }
    return Array.from(data);
  }
  if (Array.isArray(data) && data.every((element) => typeof element === "number")) {
    return data;
  }
  return null;
}

// src/canister-client/canister-client.ts
var CanisterClient = class {
  constructor(url, identity) {
    this.identity = identity;
    this.url = new URL(url);
    const canisterId = this.extractId(this.url.origin);
    const hostUrl = this.getHostUrl(this.url.origin);
    this.agent = this.createAgent(hostUrl, this.identity);
    this.actor = this.createActor(canisterId);
  }
  extractId(url) {
    var pattern = /(?:https?:\/\/)([^\/.]+)\./;
    var match = url.match(pattern);
    if (match) {
      return match[1];
    } else {
      throw new Error("Invalid URL");
    }
  }
  getHostUrl(url) {
    const textToReplace = `${this.extractId(url)}.`;
    const hostUrl = new URL(url.replace(textToReplace, "")).href;
    return hostUrl;
  }
  createAgent(hostUrl, identity) {
    const agent = new HttpAgent({
      host: hostUrl,
      identity
    });
    return agent;
  }
  createActor(canisterId) {
    return Actor.createActor(idlFactory, {
      agent: this.agent,
      canisterId
    });
  }
  replaceIdentity(identity) {
    this.identity = identity;
    this.agent.replaceIdentity(identity);
  }
  async query(method, pathname, config) {
    await this.agent.fetchRootKey().then(() => {
      console.log("Root key fetched");
    });
    const queryParams = config?.params ? `?${new URLSearchParams(config.params).toString()}` : "";
    const request = {
      method,
      url: `${pathname || "/"}${queryParams}`,
      body: [],
      headers: config?.headers ? parseHeadersRequest(config.headers) : [],
      certificate_version: []
    };
    const result = await this.actor.http_request(request);
    if (result.status_code >= 400) {
      const error = {
        data: parseBodyResponse(result.body),
        status: result.status_code,
        statusText: HttpStatus.getStatusText(result.status_code),
        headers: parseHeadersResponse(result.headers),
        request
      };
      throw error;
    }
    const response = {
      data: parseBodyResponse(result.body),
      status: result.status_code,
      statusText: HttpStatus.getStatusText(result.status_code),
      headers: parseHeadersResponse(result.headers),
      request
    };
    return response;
  }
  async update(method, pathname, data, config) {
    await this.agent.fetchRootKey().then(() => {
      console.log("Root key fetched");
    });
    const queryParams = config?.params ? `?${new URLSearchParams(config.params).toString()}` : "";
    const body = data ? parseBodyRequest(data) : [];
    const customHeaders = config?.headers ? parseHeadersRequest(config.headers) : [];
    const headers = [["Content-Length", `${body?.length ?? 0}`], ...customHeaders];
    const request = {
      method,
      url: `${pathname || "/"}${queryParams}`,
      body: data ? parseBodyRequest(data) : [],
      headers,
      certificate_version: []
    };
    const result = await this.actor.http_request_update(request);
    if (result.status_code >= 400) {
      const error = {
        data: parseBodyResponse(result.body),
        status: result.status_code,
        statusText: HttpStatus.getStatusText(result.status_code),
        headers: parseHeadersResponse(result.headers),
        request
      };
      throw error;
    }
    const response = {
      data: parseBodyResponse(result.body),
      status: result.status_code,
      statusText: HttpStatus.getStatusText(result.status_code),
      headers: parseHeadersResponse(result.headers),
      request
    };
    return response;
  }
};

// src/index.ts
var rc = (options) => {
  const { method, url, data, ...config } = options;
  switch (method) {
    case "GET":
      return rc.get(url);
    case "POST":
      return rc.post(url, data, config);
    case "PUT":
      return rc.put(url, data, config);
    case "DELETE":
      return rc.delete(url, config);
    default:
      throw new Error("Invalid method");
  }
};
rc.get = async (url, config) => {
  const { identity, ...queryConfig } = config || {};
  const urlObj = new URL(url);
  const client = config?.client || new CanisterClient(urlObj.origin, identity);
  return client.query("GET", urlObj.pathname, queryConfig);
};
rc.post = async (url, data, config) => {
  const { identity, ...postConfig } = config || {};
  const urlObj = new URL(url);
  const client = config?.client || new CanisterClient(urlObj.origin, identity);
  return client.update("POST", urlObj.pathname, data, postConfig);
};
rc.put = async (url, data, config) => {
  const { identity, ...putConfig } = config || {};
  const urlObj = new URL(url);
  const client = config?.client || new CanisterClient(urlObj.origin, identity);
  return client.update("PUT", urlObj.pathname, data, putConfig);
};
rc.delete = async (url, config) => {
  const { identity, ...deleteConfig } = config || {};
  const urlObj = new URL(url);
  const client = config?.client || new CanisterClient(urlObj.origin, identity);
  return client.update("DELETE", urlObj.pathname, {}, deleteConfig);
};
rc.create = (options) => {
  const { baseURL, identity } = options;
  const client = new CanisterClient(baseURL, identity);
  const instance = (options2) => {
    const { url } = options2;
    return rc({
      client,
      ...options2,
      url: url.startsWith("/") ? url : `/${url}`
    });
  };
  instance.replaceIdentity = (identity2) => {
    client.replaceIdentity(identity2);
  };
  instance.get = (pathname, config) => {
    const url = `${baseURL + (pathname.startsWith("/") ? pathname : `/${pathname}`)}`;
    return rc.get(url, {
      identity,
      client,
      ...config
    });
  };
  instance.post = (pathname, data, config) => {
    const url = `${baseURL + (pathname.startsWith("/") ? pathname : `/${pathname}`)}`;
    return rc.post(url, data, {
      identity,
      client,
      ...config
    });
  };
  instance.put = (pathname, data, config) => {
    const url = `${baseURL + (pathname.startsWith("/") ? pathname : `/${pathname}`)}`;
    return rc.put(url, data, {
      identity,
      client,
      ...config
    });
  };
  instance.delete = (pathname, config) => {
    const url = `${baseURL + (pathname.startsWith("/") ? pathname : `/${pathname}`)}`;
    return rc.delete(url, {
      identity,
      client,
      ...config
    });
  };
  return instance;
};
var src_default = rc;
export {
  src_default as default
};
//# sourceMappingURL=index.mjs.map