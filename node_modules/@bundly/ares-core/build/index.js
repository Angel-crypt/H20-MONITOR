"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Client: () => Client,
  DELEGATION_CHAINS_KEY: () => DELEGATION_CHAINS_KEY,
  ECDSA_KEY_LABEL: () => ECDSA_KEY_LABEL,
  ED25519_KEY_LABEL: () => ED25519_KEY_LABEL,
  EmptyStorage: () => EmptyStorage,
  IdentityManager: () => IdentityManager,
  IncompleteEd25519KeyIdentity: () => IncompleteEd25519KeyIdentity,
  InternetIdentity: () => InternetIdentity,
  KEY_IDENTITY_KEY: () => KEY_IDENTITY_KEY,
  LocalStorage: () => LocalStorage
});
module.exports = __toCommonJS(src_exports);

// src/client/client.ts
var import_agent2 = require("@dfinity/agent");
var import_events = require("events");
var import_ares_rest = __toESM(require("@bundly/ares-rest"));

// src/events/event.constants.ts
var AUTH_IDENTITY_ADDED = "auth.identity.added";
var AUTH_IDENTITY_REMOVED = "auth.identity.removed";

// src/events/event.emitter.ts
var EventEmitter = class {
  constructor(eventManager) {
    this.eventManager = eventManager;
  }
  identityAdded(identity, provider) {
    this.eventManager.emit(AUTH_IDENTITY_ADDED, { identity, provider });
  }
  identityRemoved(identity) {
    this.eventManager.emit(AUTH_IDENTITY_REMOVED, { identity });
  }
};

// src/events/event.listener.ts
var EventListener = class {
  constructor(eventManager) {
    this.eventManager = eventManager;
  }
  onIdentityAdded(callback) {
    this.eventManager.on(AUTH_IDENTITY_ADDED, callback);
  }
  onIdentityRemoved(callback) {
    this.eventManager.on(AUTH_IDENTITY_REMOVED, callback);
  }
};

// src/identity/providers/internet-identity.ts
var import_auth_client = require("@dfinity/auth-client");
var import_identity = require("@dfinity/identity");

// src/identity/incomplete-ed25519-key-identity.ts
var import_agent = require("@dfinity/agent");
var IncompleteEd25519KeyIdentity = class extends import_agent.SignIdentity {
  constructor(_publicKey) {
    super();
    this._publicKey = _publicKey;
  }
  // We don't need to implement this method
  // @ts-ignore
  sign(blob) {
  }
  getPublicKey() {
    return this._publicKey;
  }
};

// src/identity/providers/internet-identity.ts
var DEFAULT_MAX_TIME_TO_LIVE = (
  /* hours */
  BigInt(8) * /* nanoseconds */
  BigInt(36e11)
);
var EmptyStorage = class {
  get(key) {
    return Promise.resolve("");
  }
  set(key, value) {
    return Promise.resolve();
  }
  remove(key) {
    return Promise.resolve();
  }
};
var InternetIdentity = class {
  constructor(config) {
    this.config = config;
    this.name = "internet-identity";
    this.displayName = "Internet Identity";
    // TODO: Add svg logo
    this.logo = "";
  }
  async init(client, keyIdentity) {
    this.client = client;
    this.keyIdentity = keyIdentity;
  }
  async connect() {
    const { client, keyIdentity } = this;
    if (!client || !keyIdentity)
      throw new Error("init must be called before this method");
    const publicKey = import_identity.Ed25519PublicKey.from(keyIdentity.getPublicKey());
    const incompleteIdentity = new IncompleteEd25519KeyIdentity(publicKey);
    const storage = new EmptyStorage();
    const authClient = await import_auth_client.AuthClient.create({
      identity: incompleteIdentity,
      storage
    });
    return new Promise((resolve, reject) => {
      try {
        authClient.login({
          identityProvider: this.config?.providerUrl,
          maxTimeToLive: this.config?.maxTimeToLive || DEFAULT_MAX_TIME_TO_LIVE,
          onSuccess: async () => {
            const authClientIdentity = authClient.getIdentity();
            if (authClientIdentity instanceof import_identity.DelegationIdentity) {
              const delegationChain = authClientIdentity.getDelegation();
              client.addDelegationChain(delegationChain, this.name);
              resolve();
            }
            reject(new Error("Invalid delegation identity instance"));
          },
          onError: (reason) => {
            reject(new Error(reason));
          }
        });
      } catch (error) {
        reject(error);
      }
    });
  }
  async disconnect(identity) {
    if (!this.client)
      throw new Error("init must be called before this method");
    try {
      this.client.removeIdentity(identity);
    } catch (error) {
      throw error;
    }
  }
};

// src/identity/identity-manager.ts
var import_identity2 = require("@dfinity/identity");
var KEY_IDENTITY_KEY = "ARES_IDENTITY_KEY";
var DELEGATION_CHAINS_KEY = "ARES_DELEGATION_CHAINS_KEY";
var IdentityManager = class {
  constructor(storage) {
    this.storage = storage;
    this.keyIdentity = import_identity2.Ed25519KeyIdentity.generate();
  }
  async init() {
    const maybeKeyIdentity = await this.storage.getItem(KEY_IDENTITY_KEY);
    if (maybeKeyIdentity && maybeKeyIdentity !== null) {
      this.keyIdentity = import_identity2.Ed25519KeyIdentity.fromParsedJson(JSON.parse(maybeKeyIdentity));
    } else {
      this.storage.setItem(KEY_IDENTITY_KEY, JSON.stringify(this.keyIdentity.toJSON()));
    }
  }
  getKeyIdentity() {
    return this.keyIdentity;
  }
  async getDelegationChains() {
    const jsonString = await this.storage.getItem(DELEGATION_CHAINS_KEY);
    if (!jsonString) {
      return /* @__PURE__ */ new Map();
    }
    return new Map(JSON.parse(jsonString));
  }
  setDelegationChains(identities) {
    return new Promise((resolve) => {
      this.storage.setItem(DELEGATION_CHAINS_KEY, JSON.stringify([...identities]));
      resolve();
    });
  }
  async getIdentities() {
    const state = await this.getDelegationChains();
    const identities = /* @__PURE__ */ new Map();
    state.forEach((values, principal) => {
      const delegationChain = import_identity2.DelegationChain.fromJSON(values.chain);
      const delegationIdentity = import_identity2.DelegationIdentity.fromDelegation(this.keyIdentity, delegationChain);
      identities.set(principal, {
        identity: delegationIdentity,
        provider: values.provider
      });
    });
    return identities;
  }
  async addDelegationChain(chain, provider) {
    const PersistentDelegationChain = {
      chain: chain.toJSON(),
      provider
    };
    const delegationChains = await this.getDelegationChains();
    const delegationIdentity = import_identity2.DelegationIdentity.fromDelegation(this.keyIdentity, chain);
    const principal = delegationIdentity.getPrincipal();
    delegationChains.set(principal.toString(), PersistentDelegationChain);
    this.setDelegationChains(delegationChains);
    return delegationIdentity;
  }
  async removeIdentity(identity) {
    const principal = identity.getPrincipal().toString();
    const state = await this.getDelegationChains();
    state.delete(principal);
    this.setDelegationChains(state);
  }
};

// src/identity/identity-provider.ts
var ECDSA_KEY_LABEL = "ECDSA";
var ED25519_KEY_LABEL = "Ed25519";

// src/storage/local-storage.ts
var LocalStorage = class {
  async getItem(key) {
    return localStorage.getItem(key);
  }
  async setItem(key, value) {
    localStorage.setItem(key, value);
  }
  async removeItem(key) {
    localStorage.removeItem(key);
  }
};

// src/utils/url.ts
function isLocal(host) {
  const { hostname } = new URL(host);
  const localHostNames = ["127.0.0.1", "localhost"];
  const ngrokHostName = /^.*\.ngrok-free\.app$/;
  const localtunelHostName = /^.*\.loca\.lt$/;
  const isLocal2 = localHostNames.includes(hostname) || ngrokHostName.test(hostname) || localtunelHostName.test(hostname);
  return isLocal2;
}

// src/client/client.errors.ts
var CanisterDoesNotExistError = class extends Error {
  constructor(canisterId) {
    super(`Canister ${canisterId} does not exist`);
  }
};
var ProviderNotFoundError = class extends Error {
  constructor(providerName) {
    super(`Provider ${providerName} not found`);
  }
};
var AgentNotDefinedError = class extends Error {
  constructor() {
    super("You must provide an agent for the canister or set a default agent");
  }
};

// src/client/client.ts
var Client = class _Client {
  constructor(config) {
    this.config = config;
    this.eventManager = new import_events.EventEmitter();
    this.eventEmitter = new EventEmitter(this.eventManager);
    this.eventListener = new EventListener(this.eventManager);
    this.storage = config.storage;
    this.identityManager = new IdentityManager(this.storage);
  }
  async init() {
    await this.identityManager.init();
    const keyIdentity = this.identityManager.getKeyIdentity();
    const providerInits = this.getProviders().map((provider) => provider.init(this, keyIdentity));
    await Promise.all(providerInits);
  }
  createAgent(options) {
    const agent = new import_agent2.HttpAgent(options);
    isLocal(options.host) && agent.fetchRootKey().then(() => console.log("Root key fetched"));
    return agent;
  }
  async getIdentities() {
    const storedIdentities = await this.identityManager.getIdentities();
    const identities = Array.from(storedIdentities.values()).map(({ identity, provider }) => {
      return {
        identity,
        provider
      };
    });
    return identities;
  }
  async addDelegationChain(chain, provider) {
    try {
      const delegationIdentity = await this.identityManager.addDelegationChain(chain, provider);
      this.eventEmitter.identityAdded(delegationIdentity, provider);
    } catch (error) {
      throw error;
    }
  }
  async removeIdentity(identity) {
    await this.identityManager.removeIdentity(identity);
    this.eventEmitter.identityRemoved(identity);
  }
  createAgentOptions(identity, agentConfig) {
    const baseOptions = agentConfig || this.config.agentConfig;
    if (!baseOptions) {
      throw new AgentNotDefinedError();
    }
    const options = {
      ...baseOptions,
      host: baseOptions.host || "http://localhost:4943",
      identity
    };
    return options;
  }
  // TODO: Options should be optional?
  getCandidActor(name, identity, options) {
    const canister = this.config.candidCanisters?.[name];
    if (!canister) {
      throw new CanisterDoesNotExistError(name);
    }
    const agentOptions = this.createAgentOptions(identity, canister.agentConfig);
    const agent = this.createAgent({
      ...agentOptions
    });
    isLocal(agentOptions.host) && agent.fetchRootKey().then(() => console.log("Root key fetched"));
    const actor = import_agent2.Actor.createActor(canister.idlFactory, {
      ...canister.actorConfig,
      canisterId: options?.canisterId || canister.actorConfig.canisterId,
      agent
    });
    return actor;
  }
  getRestActor(name, identity) {
    const canister = this.config.restCanisters?.[name];
    if (!canister) {
      throw new CanisterDoesNotExistError(name);
    }
    const actor = import_ares_rest.default.create({
      baseURL: canister?.baseUrl,
      identity
    });
    return actor;
  }
  getProviders() {
    return this.config.providers || [];
  }
  getProvider(name) {
    const provider = this.getProviders().find((provider2) => provider2.name === name);
    if (!provider) {
      throw new ProviderNotFoundError(name);
    }
    return provider;
  }
  static create(config) {
    if (!config.storage) {
      config.storage = new LocalStorage();
    }
    return new _Client(config);
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Client,
  DELEGATION_CHAINS_KEY,
  ECDSA_KEY_LABEL,
  ED25519_KEY_LABEL,
  EmptyStorage,
  IdentityManager,
  IncompleteEd25519KeyIdentity,
  InternetIdentity,
  KEY_IDENTITY_KEY,
  LocalStorage
});
//# sourceMappingURL=index.js.map