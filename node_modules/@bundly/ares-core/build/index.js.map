{"version":3,"sources":["../src/index.ts","../src/client/client.ts","../src/events/event.constants.ts","../src/events/event.emitter.ts","../src/events/event.listener.ts","../src/identity/providers/internet-identity.ts","../src/identity/incomplete-ed25519-key-identity.ts","../src/identity/identity-manager.ts","../src/identity/identity-provider.ts","../src/storage/local-storage.ts","../src/utils/url.ts","../src/client/client.errors.ts"],"sourcesContent":["export * from \"./client\";\nexport * from \"./identity\";\nexport * from \"./storage\";\n","import { Actor, ActorSubclass, HttpAgent, HttpAgentOptions, Identity } from \"@dfinity/agent\";\nimport { DelegationChain } from \"@dfinity/identity\";\nimport { EventEmitter as EventManager } from \"events\";\n\nimport restClient, { RestClientInstance } from \"@bundly/ares-rest\";\n\nimport { EventEmitter, EventListener } from \"../events\";\nimport { IdentityManager, IdentityProvider } from \"../identity\";\nimport { ClientStorageInterface, LocalStorage } from \"../storage\";\nimport * as url from \"../utils/url\";\nimport { AgentNotDefinedError, CanisterDoesNotExistError, ProviderNotFoundError } from \"./client.errors\";\nimport {\n  ClientConfig,\n  CreateClientConfig,\n  GetCandidActorOptions,\n  GetIdentitiesResult,\n  IdentityProviders,\n} from \"./client.types\";\n\nexport class Client {\n  private identityManager: IdentityManager;\n  public eventEmitter: EventEmitter;\n  public eventListener: EventListener;\n  private storage: ClientStorageInterface;\n  private eventManager = new EventManager();\n\n  private constructor(private readonly config: ClientConfig) {\n    this.eventEmitter = new EventEmitter(this.eventManager);\n    this.eventListener = new EventListener(this.eventManager);\n\n    this.storage = config.storage;\n    this.identityManager = new IdentityManager(this.storage);\n  }\n\n  public async init(): Promise<void> {\n    await this.identityManager.init();\n    const keyIdentity = this.identityManager.getKeyIdentity();\n\n    // Initialize all providers\n    const providerInits = this.getProviders().map((provider) => provider.init(this, keyIdentity));\n    await Promise.all(providerInits);\n  }\n\n  private createAgent(options: HttpAgentOptions): HttpAgent {\n    const agent = new HttpAgent(options);\n\n    // Host is defined in createAgentOptions\n    url.isLocal(options.host!) && agent.fetchRootKey().then(() => console.log(\"Root key fetched\"));\n\n    return agent;\n  }\n\n  public async getIdentities(): Promise<GetIdentitiesResult> {\n    const storedIdentities = await this.identityManager.getIdentities();\n\n    const identities = Array.from(storedIdentities.values()).map(({ identity, provider }) => {\n      return {\n        identity,\n        provider,\n      };\n    });\n\n    return identities;\n  }\n\n  public async addDelegationChain(chain: DelegationChain, provider: string): Promise<void> {\n    try {\n      const delegationIdentity = await this.identityManager.addDelegationChain(chain, provider);\n\n      this.eventEmitter.identityAdded(delegationIdentity, provider);\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  public async removeIdentity(identity: Identity): Promise<void> {\n    await this.identityManager.removeIdentity(identity);\n    this.eventEmitter.identityRemoved(identity);\n  }\n\n  private createAgentOptions(identity: Identity, agentConfig?: HttpAgentOptions) {\n    const baseOptions = agentConfig || this.config.agentConfig;\n\n    if (!baseOptions) {\n      throw new AgentNotDefinedError();\n    }\n\n    const options = {\n      ...baseOptions,\n      host: baseOptions.host || \"http://localhost:4943\",\n      identity,\n    };\n\n    return options;\n  }\n\n  // TODO: Options should be optional?\n  public getCandidActor(name: string, identity: Identity, options?: GetCandidActorOptions): ActorSubclass {\n    const canister = this.config.candidCanisters?.[name];\n\n    if (!canister) {\n      throw new CanisterDoesNotExistError(name);\n    }\n\n    const agentOptions = this.createAgentOptions(identity, canister.agentConfig);\n    const agent = this.createAgent({\n      ...agentOptions,\n    });\n\n    url.isLocal(agentOptions.host) && agent.fetchRootKey().then(() => console.log(\"Root key fetched\"));\n\n    const actor = Actor.createActor(canister.idlFactory, {\n      ...canister.actorConfig,\n      canisterId: options?.canisterId || canister.actorConfig.canisterId,\n      agent,\n    });\n\n    return actor;\n  }\n\n  public getRestActor(name: string, identity: Identity): RestClientInstance {\n    const canister = this.config.restCanisters?.[name];\n\n    if (!canister) {\n      throw new CanisterDoesNotExistError(name);\n    }\n\n    // TODO: Modify restClient to accept an agent optionally\n    const actor = restClient.create({\n      baseURL: canister?.baseUrl,\n      identity,\n    });\n\n    return actor;\n  }\n\n  public getProviders(): IdentityProviders {\n    return this.config.providers || [];\n  }\n\n  public getProvider(name: string): IdentityProvider {\n    const provider = this.getProviders().find((provider) => provider.name === name);\n\n    if (!provider) {\n      throw new ProviderNotFoundError(name);\n    }\n\n    return provider;\n  }\n\n  public static create(config: CreateClientConfig): Client {\n    if (!config.storage) {\n      config.storage = new LocalStorage();\n    }\n\n    return new Client(config as ClientConfig);\n  }\n}\n","export const AUTH_IDENTITY_ADDED = \"auth.identity.added\";\nexport const AUTH_IDENTITY_REMOVED = \"auth.identity.removed\";\n","import { Identity } from \"@dfinity/agent\";\nimport { EventEmitter as EventManager } from \"events\";\n\nimport { AUTH_IDENTITY_ADDED, AUTH_IDENTITY_REMOVED } from \"./event.constants\";\n\nexport class EventEmitter {\n  constructor(private readonly eventManager: EventManager) {}\n\n  public identityAdded(identity: Identity, provider: string): void {\n    this.eventManager.emit(AUTH_IDENTITY_ADDED, { identity, provider });\n  }\n\n  public identityRemoved(identity: Identity): void {\n    this.eventManager.emit(AUTH_IDENTITY_REMOVED, { identity });\n  }\n}\n","import { Identity } from \"@dfinity/agent\";\nimport { EventEmitter as EventManager } from \"events\";\n\nimport { AUTH_IDENTITY_ADDED, AUTH_IDENTITY_REMOVED } from \"./event.constants\";\n\nexport type OnIdentityAddedCallbackPayload = {\n  identity: Identity;\n  provider: string;\n};\nexport type OnIdentityAddedCallback = (payload: OnIdentityAddedCallbackPayload) => void;\n\nexport type OnIdentityRemoveCallbackPayload = {\n  identity: Identity;\n};\nexport type OnIdentityRemoveCallback = (payload: OnIdentityRemoveCallbackPayload) => void;\n\nexport class EventListener {\n  constructor(private readonly eventManager: EventManager) {}\n\n  public onIdentityAdded(callback: OnIdentityAddedCallback): void {\n    this.eventManager.on(AUTH_IDENTITY_ADDED, callback);\n  }\n\n  public onIdentityRemoved(callback: OnIdentityRemoveCallback): void {\n    this.eventManager.on(AUTH_IDENTITY_REMOVED, callback);\n  }\n}\n","import { Identity } from \"@dfinity/agent\";\nimport { AuthClient, AuthClientStorage } from \"@dfinity/auth-client\";\nimport { StoredKey } from \"@dfinity/auth-client/lib/cjs/storage\";\nimport { DelegationIdentity, Ed25519KeyIdentity, Ed25519PublicKey } from \"@dfinity/identity\";\n\nimport { Client } from \"../../client\";\nimport { IdentityProvider } from \"../identity-provider\";\nimport { IncompleteEd25519KeyIdentity } from \"../incomplete-ed25519-key-identity\";\n\nexport type InternetIdentityCreateOptions = {\n  providerUrl?: string;\n  maxTimeToLive?: bigint;\n};\n\n// Set default maxTimeToLive to 8 hours\nconst DEFAULT_MAX_TIME_TO_LIVE = /* hours */ BigInt(8) * /* nanoseconds */ BigInt(3_600_000_000_000);\n\nexport class EmptyStorage implements AuthClientStorage {\n  public get(key: string): Promise<StoredKey> {\n    return Promise.resolve(\"\");\n  }\n\n  public set(key: string, value: any): Promise<void> {\n    return Promise.resolve();\n  }\n\n  public remove(key: string): Promise<void> {\n    return Promise.resolve();\n  }\n}\n\nexport class InternetIdentity implements IdentityProvider {\n  public readonly name = \"internet-identity\";\n  public readonly displayName = \"Internet Identity\";\n  // TODO: Add svg logo\n  public readonly logo = \"\";\n  private client: Client | undefined;\n  private keyIdentity: Ed25519KeyIdentity | undefined;\n\n  constructor(private readonly config?: InternetIdentityCreateOptions) {}\n\n  public async init(client: Client, keyIdentity: Ed25519KeyIdentity): Promise<void> {\n    this.client = client;\n    this.keyIdentity = keyIdentity;\n  }\n\n  public async connect() {\n    const { client, keyIdentity } = this;\n\n    if (!client || !keyIdentity) throw new Error(\"init must be called before this method\");\n\n    const publicKey = Ed25519PublicKey.from(keyIdentity.getPublicKey());\n    const incompleteIdentity = new IncompleteEd25519KeyIdentity(publicKey);\n    const storage = new EmptyStorage();\n    const authClient = await AuthClient.create({\n      identity: incompleteIdentity,\n      storage,\n    });\n\n    return new Promise<void>((resolve, reject) => {\n      try {\n        authClient.login({\n          identityProvider: this.config?.providerUrl,\n          maxTimeToLive: this.config?.maxTimeToLive || DEFAULT_MAX_TIME_TO_LIVE,\n          onSuccess: async () => {\n            const authClientIdentity = authClient.getIdentity();\n\n            if (authClientIdentity instanceof DelegationIdentity) {\n              const delegationChain = authClientIdentity.getDelegation();\n              client.addDelegationChain(delegationChain, this.name);\n              resolve();\n            }\n\n            reject(new Error(\"Invalid delegation identity instance\"));\n          },\n          onError: (reason) => {\n            reject(new Error(reason));\n          },\n        });\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  public async disconnect(identity: Identity): Promise<void> {\n    if (!this.client) throw new Error(\"init must be called before this method\");\n\n    try {\n      this.client.removeIdentity(identity);\n    } catch (error) {\n      throw error;\n    }\n  }\n}\n","import { SignIdentity, Signature } from \"@dfinity/agent\";\nimport { Ed25519PublicKey } from \"@dfinity/identity\";\n\nexport class IncompleteEd25519KeyIdentity extends SignIdentity {\n  constructor(private readonly _publicKey: Ed25519PublicKey) {\n    super();\n  }\n\n  // We don't need to implement this method\n  // @ts-ignore\n  public sign(blob: ArrayBuffer): Promise<Signature> {}\n\n  public getPublicKey(): Ed25519PublicKey {\n    return this._publicKey;\n  }\n}\n","import { Identity } from \"@dfinity/agent\";\nimport {\n  DelegationChain,\n  DelegationIdentity,\n  Ed25519KeyIdentity,\n  JsonnableDelegationChain,\n} from \"@dfinity/identity\";\nimport { ClientStorageInterface } from \"storage\";\n\nexport const KEY_IDENTITY_KEY = \"ARES_IDENTITY_KEY\";\nexport const DELEGATION_CHAINS_KEY = \"ARES_DELEGATION_CHAINS_KEY\";\n\nexport type PersistentDelegationChain = {\n  chain: JsonnableDelegationChain;\n  provider: string;\n};\n\nexport type StoredIdentity = {\n  identity: Identity;\n  provider: string;\n};\n\nexport type StoredIdentityMap = Map<string, StoredIdentity>;\n\nexport class IdentityManager {\n  private keyIdentity: Ed25519KeyIdentity = Ed25519KeyIdentity.generate();\n\n  constructor(private storage: ClientStorageInterface) {}\n\n  public async init(): Promise<void> {\n    const maybeKeyIdentity = await this.storage.getItem(KEY_IDENTITY_KEY);\n\n    if (maybeKeyIdentity && maybeKeyIdentity !== null) {\n      this.keyIdentity = Ed25519KeyIdentity.fromParsedJson(JSON.parse(maybeKeyIdentity));\n    } else {\n      this.storage.setItem(KEY_IDENTITY_KEY, JSON.stringify(this.keyIdentity.toJSON()));\n    }\n  }\n\n  public getKeyIdentity(): Ed25519KeyIdentity {\n    return this.keyIdentity;\n  }\n\n  private async getDelegationChains(): Promise<Map<string, PersistentDelegationChain>> {\n    const jsonString = await this.storage.getItem(DELEGATION_CHAINS_KEY);\n\n    if (!jsonString) {\n      return new Map();\n    }\n\n    return new Map(JSON.parse(jsonString));\n  }\n\n  private setDelegationChains(identities: Map<string, PersistentDelegationChain>): Promise<void> {\n    return new Promise((resolve) => {\n      this.storage.setItem(DELEGATION_CHAINS_KEY, JSON.stringify([...identities]));\n\n      resolve();\n    });\n  }\n\n  public async getIdentities(): Promise<StoredIdentityMap> {\n    const state = await this.getDelegationChains();\n    const identities = new Map<string, StoredIdentity>();\n\n    state.forEach((values, principal) => {\n      const delegationChain = DelegationChain.fromJSON(values.chain);\n      const delegationIdentity = DelegationIdentity.fromDelegation(this.keyIdentity, delegationChain);\n\n      identities.set(principal, {\n        identity: delegationIdentity,\n        provider: values.provider,\n      });\n    });\n\n    return identities;\n  }\n\n  public async addDelegationChain(chain: DelegationChain, provider: string): Promise<DelegationIdentity> {\n    const PersistentDelegationChain: PersistentDelegationChain = {\n      chain: chain.toJSON(),\n      provider,\n    };\n\n    const delegationChains = await this.getDelegationChains();\n    const delegationIdentity = DelegationIdentity.fromDelegation(this.keyIdentity, chain);\n    const principal = delegationIdentity.getPrincipal();\n    delegationChains.set(principal.toString(), PersistentDelegationChain);\n    this.setDelegationChains(delegationChains);\n\n    return delegationIdentity;\n  }\n\n  public async removeIdentity(identity: Identity): Promise<void> {\n    const principal = identity.getPrincipal().toString();\n    const state = await this.getDelegationChains();\n    state.delete(principal);\n    this.setDelegationChains(state);\n  }\n}\n","import { Ed25519KeyIdentity } from \"@dfinity/identity\";\n\nimport { Client } from \"../client/client\";\n\nexport const ECDSA_KEY_LABEL = \"ECDSA\";\nexport const ED25519_KEY_LABEL = \"Ed25519\";\nexport type BaseKeyType = typeof ECDSA_KEY_LABEL | typeof ED25519_KEY_LABEL;\n\nexport interface IdentityProvider {\n  name: string;\n  displayName: string;\n  logo: string;\n  init: (client: Client, keyIdentity: Ed25519KeyIdentity) => Promise<void>;\n  connect: () => Promise<void>;\n  // TODO: Maybe this method is not needed\n  disconnect: (identity: Ed25519KeyIdentity) => Promise<void>;\n}\n","import { ClientStorageInterface } from \"./storage.interface\";\n\nexport class LocalStorage implements ClientStorageInterface {\n  public async getItem(key: string) {\n    return localStorage.getItem(key);\n  }\n\n  public async setItem(key: string, value: string) {\n    localStorage.setItem(key, value);\n  }\n\n  public async removeItem(key: string) {\n    localStorage.removeItem(key);\n  }\n}\n","export function isLocal(host: string): boolean {\n  const { hostname } = new URL(host);\n  const localHostNames = [\"127.0.0.1\", \"localhost\"];\n  // TODO: wildcard for ngrok free and premium\n  const ngrokHostName = /^.*\\.ngrok-free\\.app$/;\n  const localtunelHostName = /^.*\\.loca\\.lt$/;\n\n  const isLocal =\n    localHostNames.includes(hostname) || ngrokHostName.test(hostname) || localtunelHostName.test(hostname);\n\n  return isLocal;\n}\n","export class CanisterDoesNotExistError extends Error {\n  constructor(canisterId: string) {\n    super(`Canister ${canisterId} does not exist`);\n  }\n}\n\nexport class ProviderNotFoundError extends Error {\n  constructor(providerName: string) {\n    super(`Provider ${providerName} not found`);\n  }\n}\n\nexport class AgentNotDefinedError extends Error {\n  constructor() {\n    super(\"You must provide an agent for the canister or set a default agent\");\n  }\n}\n"],"mappings":"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","names":["import_agent","import_identity","isLocal","EventManager","restClient","provider"]}