// src/client/client.ts
import { Actor, HttpAgent } from "@dfinity/agent";
import { EventEmitter as EventManager } from "events";
import restClient from "@bundly/ares-rest";

// src/events/event.constants.ts
var AUTH_IDENTITY_ADDED = "auth.identity.added";
var AUTH_IDENTITY_REMOVED = "auth.identity.removed";

// src/events/event.emitter.ts
var EventEmitter = class {
  constructor(eventManager) {
    this.eventManager = eventManager;
  }
  identityAdded(identity, provider) {
    this.eventManager.emit(AUTH_IDENTITY_ADDED, { identity, provider });
  }
  identityRemoved(identity) {
    this.eventManager.emit(AUTH_IDENTITY_REMOVED, { identity });
  }
};

// src/events/event.listener.ts
var EventListener = class {
  constructor(eventManager) {
    this.eventManager = eventManager;
  }
  onIdentityAdded(callback) {
    this.eventManager.on(AUTH_IDENTITY_ADDED, callback);
  }
  onIdentityRemoved(callback) {
    this.eventManager.on(AUTH_IDENTITY_REMOVED, callback);
  }
};

// src/identity/providers/internet-identity.ts
import { AuthClient } from "@dfinity/auth-client";
import { DelegationIdentity, Ed25519PublicKey } from "@dfinity/identity";

// src/identity/incomplete-ed25519-key-identity.ts
import { SignIdentity } from "@dfinity/agent";
var IncompleteEd25519KeyIdentity = class extends SignIdentity {
  constructor(_publicKey) {
    super();
    this._publicKey = _publicKey;
  }
  // We don't need to implement this method
  // @ts-ignore
  sign(blob) {
  }
  getPublicKey() {
    return this._publicKey;
  }
};

// src/identity/providers/internet-identity.ts
var DEFAULT_MAX_TIME_TO_LIVE = (
  /* hours */
  BigInt(8) * /* nanoseconds */
  BigInt(36e11)
);
var EmptyStorage = class {
  get(key) {
    return Promise.resolve("");
  }
  set(key, value) {
    return Promise.resolve();
  }
  remove(key) {
    return Promise.resolve();
  }
};
var InternetIdentity = class {
  constructor(config) {
    this.config = config;
    this.name = "internet-identity";
    this.displayName = "Internet Identity";
    // TODO: Add svg logo
    this.logo = "";
  }
  async init(client, keyIdentity) {
    this.client = client;
    this.keyIdentity = keyIdentity;
  }
  async connect() {
    const { client, keyIdentity } = this;
    if (!client || !keyIdentity)
      throw new Error("init must be called before this method");
    const publicKey = Ed25519PublicKey.from(keyIdentity.getPublicKey());
    const incompleteIdentity = new IncompleteEd25519KeyIdentity(publicKey);
    const storage = new EmptyStorage();
    const authClient = await AuthClient.create({
      identity: incompleteIdentity,
      storage
    });
    return new Promise((resolve, reject) => {
      try {
        authClient.login({
          identityProvider: this.config?.providerUrl,
          maxTimeToLive: this.config?.maxTimeToLive || DEFAULT_MAX_TIME_TO_LIVE,
          onSuccess: async () => {
            const authClientIdentity = authClient.getIdentity();
            if (authClientIdentity instanceof DelegationIdentity) {
              const delegationChain = authClientIdentity.getDelegation();
              client.addDelegationChain(delegationChain, this.name);
              resolve();
            }
            reject(new Error("Invalid delegation identity instance"));
          },
          onError: (reason) => {
            reject(new Error(reason));
          }
        });
      } catch (error) {
        reject(error);
      }
    });
  }
  async disconnect(identity) {
    if (!this.client)
      throw new Error("init must be called before this method");
    try {
      this.client.removeIdentity(identity);
    } catch (error) {
      throw error;
    }
  }
};

// src/identity/identity-manager.ts
import {
  DelegationChain,
  DelegationIdentity as DelegationIdentity2,
  Ed25519KeyIdentity as Ed25519KeyIdentity2
} from "@dfinity/identity";
var KEY_IDENTITY_KEY = "ARES_IDENTITY_KEY";
var DELEGATION_CHAINS_KEY = "ARES_DELEGATION_CHAINS_KEY";
var IdentityManager = class {
  constructor(storage) {
    this.storage = storage;
    this.keyIdentity = Ed25519KeyIdentity2.generate();
  }
  async init() {
    const maybeKeyIdentity = await this.storage.getItem(KEY_IDENTITY_KEY);
    if (maybeKeyIdentity && maybeKeyIdentity !== null) {
      this.keyIdentity = Ed25519KeyIdentity2.fromParsedJson(JSON.parse(maybeKeyIdentity));
    } else {
      this.storage.setItem(KEY_IDENTITY_KEY, JSON.stringify(this.keyIdentity.toJSON()));
    }
  }
  getKeyIdentity() {
    return this.keyIdentity;
  }
  async getDelegationChains() {
    const jsonString = await this.storage.getItem(DELEGATION_CHAINS_KEY);
    if (!jsonString) {
      return /* @__PURE__ */ new Map();
    }
    return new Map(JSON.parse(jsonString));
  }
  setDelegationChains(identities) {
    return new Promise((resolve) => {
      this.storage.setItem(DELEGATION_CHAINS_KEY, JSON.stringify([...identities]));
      resolve();
    });
  }
  async getIdentities() {
    const state = await this.getDelegationChains();
    const identities = /* @__PURE__ */ new Map();
    state.forEach((values, principal) => {
      const delegationChain = DelegationChain.fromJSON(values.chain);
      const delegationIdentity = DelegationIdentity2.fromDelegation(this.keyIdentity, delegationChain);
      identities.set(principal, {
        identity: delegationIdentity,
        provider: values.provider
      });
    });
    return identities;
  }
  async addDelegationChain(chain, provider) {
    const PersistentDelegationChain = {
      chain: chain.toJSON(),
      provider
    };
    const delegationChains = await this.getDelegationChains();
    const delegationIdentity = DelegationIdentity2.fromDelegation(this.keyIdentity, chain);
    const principal = delegationIdentity.getPrincipal();
    delegationChains.set(principal.toString(), PersistentDelegationChain);
    this.setDelegationChains(delegationChains);
    return delegationIdentity;
  }
  async removeIdentity(identity) {
    const principal = identity.getPrincipal().toString();
    const state = await this.getDelegationChains();
    state.delete(principal);
    this.setDelegationChains(state);
  }
};

// src/identity/identity-provider.ts
var ECDSA_KEY_LABEL = "ECDSA";
var ED25519_KEY_LABEL = "Ed25519";

// src/storage/local-storage.ts
var LocalStorage = class {
  async getItem(key) {
    return localStorage.getItem(key);
  }
  async setItem(key, value) {
    localStorage.setItem(key, value);
  }
  async removeItem(key) {
    localStorage.removeItem(key);
  }
};

// src/utils/url.ts
function isLocal(host) {
  const { hostname } = new URL(host);
  const localHostNames = ["127.0.0.1", "localhost"];
  const ngrokHostName = /^.*\.ngrok-free\.app$/;
  const localtunelHostName = /^.*\.loca\.lt$/;
  const isLocal2 = localHostNames.includes(hostname) || ngrokHostName.test(hostname) || localtunelHostName.test(hostname);
  return isLocal2;
}

// src/client/client.errors.ts
var CanisterDoesNotExistError = class extends Error {
  constructor(canisterId) {
    super(`Canister ${canisterId} does not exist`);
  }
};
var ProviderNotFoundError = class extends Error {
  constructor(providerName) {
    super(`Provider ${providerName} not found`);
  }
};
var AgentNotDefinedError = class extends Error {
  constructor() {
    super("You must provide an agent for the canister or set a default agent");
  }
};

// src/client/client.ts
var Client = class _Client {
  constructor(config) {
    this.config = config;
    this.eventManager = new EventManager();
    this.eventEmitter = new EventEmitter(this.eventManager);
    this.eventListener = new EventListener(this.eventManager);
    this.storage = config.storage;
    this.identityManager = new IdentityManager(this.storage);
  }
  async init() {
    await this.identityManager.init();
    const keyIdentity = this.identityManager.getKeyIdentity();
    const providerInits = this.getProviders().map((provider) => provider.init(this, keyIdentity));
    await Promise.all(providerInits);
  }
  createAgent(options) {
    const agent = new HttpAgent(options);
    isLocal(options.host) && agent.fetchRootKey().then(() => console.log("Root key fetched"));
    return agent;
  }
  async getIdentities() {
    const storedIdentities = await this.identityManager.getIdentities();
    const identities = Array.from(storedIdentities.values()).map(({ identity, provider }) => {
      return {
        identity,
        provider
      };
    });
    return identities;
  }
  async addDelegationChain(chain, provider) {
    try {
      const delegationIdentity = await this.identityManager.addDelegationChain(chain, provider);
      this.eventEmitter.identityAdded(delegationIdentity, provider);
    } catch (error) {
      throw error;
    }
  }
  async removeIdentity(identity) {
    await this.identityManager.removeIdentity(identity);
    this.eventEmitter.identityRemoved(identity);
  }
  createAgentOptions(identity, agentConfig) {
    const baseOptions = agentConfig || this.config.agentConfig;
    if (!baseOptions) {
      throw new AgentNotDefinedError();
    }
    const options = {
      ...baseOptions,
      host: baseOptions.host || "http://localhost:4943",
      identity
    };
    return options;
  }
  // TODO: Options should be optional?
  getCandidActor(name, identity, options) {
    const canister = this.config.candidCanisters?.[name];
    if (!canister) {
      throw new CanisterDoesNotExistError(name);
    }
    const agentOptions = this.createAgentOptions(identity, canister.agentConfig);
    const agent = this.createAgent({
      ...agentOptions
    });
    isLocal(agentOptions.host) && agent.fetchRootKey().then(() => console.log("Root key fetched"));
    const actor = Actor.createActor(canister.idlFactory, {
      ...canister.actorConfig,
      canisterId: options?.canisterId || canister.actorConfig.canisterId,
      agent
    });
    return actor;
  }
  getRestActor(name, identity) {
    const canister = this.config.restCanisters?.[name];
    if (!canister) {
      throw new CanisterDoesNotExistError(name);
    }
    const actor = restClient.create({
      baseURL: canister?.baseUrl,
      identity
    });
    return actor;
  }
  getProviders() {
    return this.config.providers || [];
  }
  getProvider(name) {
    const provider = this.getProviders().find((provider2) => provider2.name === name);
    if (!provider) {
      throw new ProviderNotFoundError(name);
    }
    return provider;
  }
  static create(config) {
    if (!config.storage) {
      config.storage = new LocalStorage();
    }
    return new _Client(config);
  }
};
export {
  Client,
  DELEGATION_CHAINS_KEY,
  ECDSA_KEY_LABEL,
  ED25519_KEY_LABEL,
  EmptyStorage,
  IdentityManager,
  IncompleteEd25519KeyIdentity,
  InternetIdentity,
  KEY_IDENTITY_KEY,
  LocalStorage
};
//# sourceMappingURL=index.mjs.map